-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | ORM
--   
--   ORM library for PostgreSQL
@package orville
@version 0.8.3.0


module Database.Orville.Expr
data RawExpr
rawSql :: String -> RawExpr
class GenerateSql expr
generateSql :: GenerateSql expr => expr -> RawExpr
data Expr a
rawSqlExpr :: String -> Expr a
expr :: a -> Expr a
type NameExpr = Expr NameForm
data NameForm
unescapedName :: NameForm -> String
type SelectExpr = Expr SelectForm
data SelectForm
SelectForm :: NameForm -> Maybe NameForm -> Maybe NameForm -> SelectForm
[selectFormColumn] :: SelectForm -> NameForm
[selectFormTable] :: SelectForm -> Maybe NameForm
[selectFormAlias] :: SelectForm -> Maybe NameForm
selectColumn :: NameForm -> SelectForm
qualified :: SelectForm -> NameForm -> SelectForm
aliased :: SelectForm -> NameForm -> SelectForm


module Database.Orville.PostgresSQL

-- | <a>createConnectionPool</a> allocates a pool of connections to a
--   PosgreSQL server. The returned pool can be used as the endpoint to
--   <a>newOrvilleEnv</a> to construct.
createConnectionPool :: Int -> NominalDiffTime -> Int -> String -> IO (Pool Connection)
data Pool a
data Connection


module Database.Orville.Select
data Select row
selectQuery :: FromSql row -> FromClause -> SelectOptions -> Select row
selectQueryTable :: TableDefinition entity -> SelectOptions -> Select (entity Record)
selectQueryRows :: [SelectExpr] -> FromClause -> SelectOptions -> Select [(String, SqlValue)]
selectQueryRaw :: FromSql row -> String -> [SqlValue] -> Select row
selectQueryRawRows :: String -> [SqlValue] -> Select [(String, SqlValue)]
selectQueryColumns :: [SelectExpr] -> FromSql row -> FromClause -> SelectOptions -> Select row
selectField :: FieldDefinition -> SelectForm
data FromClause
fromClauseRaw :: String -> FromClause
fromClauseTableName :: String -> FromClause
fromClauseTable :: TableDefinition entity -> FromClause
runSelect :: Select row -> Orville [row]


module Database.Orville.Raw
selectSql :: String -> [SqlValue] -> FromSql result -> Orville [result]
selectSqlRows :: String -> [SqlValue] -> Orville ResultSet
decodeSqlRows :: FromSql result -> ResultSet -> Orville [result]
type ResultSet = [[(String, SqlValue)]]
updateSql :: String -> [SqlValue] -> Orville Integer
withConnection :: MonadOrville conn m => (conn -> m a) -> m a
withTransaction :: MonadOrville conn m => m a -> m a


module Database.Orville.Core

-- | A <a>TableDefinition</a> is the center of the Orville universe. A
--   <a>TableDefinition</a> defines the structure of a table in the
--   database and associates it with a Haskell datatype, usually a Haskell
--   record type. The <a>TableDefinition</a> must specify how the Haskell
--   type is converted to and from the database schema, as as well as
--   provide same basic utility functions required by Orville for
--   interacting with the Haskell datatype.
--   
--   Usually you will use <tt>TableParams</tt> to construct a
--   <a>TableDefinition</a> in a more concise way. This type is provided as
--   an escape hatch for any situations where <tt>TableParams</tt> is too
--   restrictive for the sql mapping required by a type.
data TableDefinition entity
TableDefinition :: String -> [FieldDefinition] -> [String] -> FromSql (entity Record) -> (forall key. ToSql (entity key) ()) -> (forall key1 key2. key2 -> entity key1 -> entity key2) -> (forall key. entity key -> key) -> TableComments () -> TableDefinition entity

-- | The name of the table in the database.
[tableName] :: TableDefinition entity -> String

-- | A list of field definitions defining the table structure
[tableFields] :: TableDefinition entity -> [FieldDefinition]

-- | A list of any columns that may be deleted from the table by Orville.
--   (Orville will never delete a column without being told it is safe)
[tableSafeToDelete] :: TableDefinition entity -> [String]

-- | A definition of how to convert the haskell type from a sql row
[tableFromSql] :: TableDefinition entity -> FromSql (entity Record)

-- | A definition of how to convert the haskell type to a sql row
[tableToSql] :: TableDefinition entity -> forall key. ToSql (entity key) ()

-- | A function to set the key on the entity
[tableSetKey] :: TableDefinition entity -> forall key1 key2. key2 -> entity key1 -> entity key2

-- | A function to get the key on the entity
[tableGetKey] :: TableDefinition entity -> forall key. entity key -> key

-- | Any comments that might be interesting for developers to see. These
--   comments will get printed in the log if there is an erro while
--   attempting to migrate the table.
[tableComments] :: TableDefinition entity -> TableComments ()

-- | <a>mkTableDefinition</a> converts a <a>TableParams</a> to
--   <a>TableDefinition</a>. Usually this is used directly on a record
--   literal of the <a>TableParams</a>. For example:
--   
--   <pre>
--   data Foo key = Foo key { fooId :: Record }
--   myTable :: TableDefinition Foo
--   myTable = mkTableDefinition $
--     TableParams
--       { tblName = "foo"
--       , tblMapper = User <a>$</a> attrField fooId idField
--       , tableSafeToDelete = []
--       , tblSetKey = key foo -&gt; foo { fooId = key }
--       , tblGetKey = fooId
--       , tblComments = []
--       }
--   </pre>
mkTableDefinition :: TableParams entity -> TableDefinition entity

-- | <a>TableParams</a> is the simplest way to make a
--   <a>TableDefinition</a>. You can use <a>mkTableDefinition</a> to make a
--   definition from the simplified params. Where <a>TableDefinition</a>
--   requires the <a>tableFields</a>, <a>tableFromSql</a>, and
--   <a>tableToSql</a> to all be defined separately and kept in sync,
--   <a>TableParams</a> provides a single <a>tblMapper</a> field that
--   specifies all three simultaneously and ensures they are consistent
--   with one another.
data TableParams entity
TableParams :: String -> RelationalMap (entity Record) (entity Record) -> [String] -> (forall key1 key2. key2 -> entity key1 -> entity key2) -> (forall key. entity key -> key) -> TableComments () -> TableParams entity

-- | The name of the table in the database
[tblName] :: TableParams entity -> String

-- | The relational mapping that defines how the Haskell entity type is
--   converted both to and from sql. The fields utilized in the mapping are
--   used to automatically build the list of <tt>FieldDefinitions</tt> that
--   define the structure of the table in the database.
[tblMapper] :: TableParams entity -> RelationalMap (entity Record) (entity Record)

-- | A list of any columns that may be deleted from the table by Orville.
--   (Orville will never delete a column without being told it is safe)
[tblSafeToDelete] :: TableParams entity -> [String]

-- | A function to set the key on the entity
[tblSetKey] :: TableParams entity -> forall key1 key2. key2 -> entity key1 -> entity key2

-- | A function to get the key on the entity
[tblGetKey] :: TableParams entity -> forall key. entity key -> key

-- | Any comments that might be interesting for developers to see. These
--   comments will get printed in the log if there is an erro while
--   attempting to migrate the table.
[tblComments] :: TableParams entity -> TableComments ()
data RelationalMap a b
mapAttr :: (a -> b) -> RelationalMap b c -> RelationalMap a c
mapField :: (Convertible a SqlValue, Convertible SqlValue a) => FieldDefinition -> RelationalMap a a
attrField :: (Convertible b SqlValue, Convertible SqlValue b) => (a -> b) -> FieldDefinition -> RelationalMap a b
maybeMapper :: RelationalMap a b -> RelationalMap (Maybe a) (Maybe b)
prefixMap :: String -> RelationalMap a b -> RelationalMap a b
partialMap :: RelationalMap a (Either String a) -> RelationalMap a a
readOnlyMap :: RelationalMap a b -> RelationalMap c b
tablePrimaryKey :: TableDefinition entity -> FieldDefinition

-- | <a>OrvilleEnv</a> tracks all the environment information required for
--   an 'OrvilleT conn m' Monad to operate. Use <a>newOrvilleEnv</a> to
--   construct one.
data OrvilleEnv conn

-- | <a>newOrvilleEnv</a> initialized an <a>OrvilleEnv</a> for service. The
--   connection pool provided will be used to obtain connections to the
--   database ase required. You can use the <a>createConnectionPool</a>
--   utility function to create a connection pool to a PosgreSQL server.
newOrvilleEnv :: Pool conn -> OrvilleEnv conn
ormEnvPool :: OrvilleEnv conn -> Pool conn
type Orville a = forall m conn. (MonadFail m, MonadOrville conn m, MonadThrow m) => m a
data OrvilleT conn m a
unOrvilleT :: OrvilleT conn m a -> ReaderT (OrvilleEnv conn) m a

-- | <a>SqlValue</a> is the main type for expressing Haskell values to SQL
--   databases.
--   
--   <i>INTRODUCTION TO SQLVALUE</i>
--   
--   This type is used to marshall Haskell data to and from database APIs.
--   HDBC driver interfaces will do their best to use the most accurate and
--   efficient way to send a particular value to the database server.
--   
--   Values read back from the server are constructed with the most
--   appropriate <a>SqlValue</a> constructor. <a>fromSql</a> or
--   <a>safeFromSql</a> can then be used to convert them into whatever type
--   is needed locally in Haskell.
--   
--   Most people will use <a>toSql</a> and <a>fromSql</a> instead of
--   manipulating <a>SqlValue</a>s directly.
--   
--   <i>EASY CONVERSIONS BETWEEN HASKELL TYPES</i>
--   
--   Conversions are powerful; for instance, you can call <a>fromSql</a> on
--   a SqlInt32 and get a String or a Double out of it. This class attempts
--   to Do The Right Thing whenever possible, and will raise an error when
--   asked to do something incorrect. In particular, when converting to any
--   type except a Maybe, <a>SqlNull</a> as the input will cause an error
--   to be raised.
--   
--   Conversions are implemented in terms of the <a>Data.Convertible</a>
--   module, part of the convertible package. You can refer to its
--   documentation, and import that module, if you wish to parse the Left
--   result from <a>safeFromSql</a> yourself, or write your own conversion
--   instances.
--   
--   Here are some notes about conversion:
--   
--   <ul>
--   <li>Fractions of a second are not preserved on time values</li>
--   <li>There is no <tt>safeToSql</tt> because <a>toSql</a> never
--   fails.</li>
--   </ul>
--   
--   See also <a>toSql</a>, <a>safeFromSql</a>, <a>fromSql</a>,
--   <a>nToSql</a>, <a>iToSql</a>, <a>posixToSql</a>.
--   
--   <i>ERROR CONDITIONS</i>
--   
--   There may sometimes be an error during conversion. For instance, if
--   you have a <a>SqlString</a> and are attempting to convert it to an
--   Integer, but it doesn't parse as an Integer, you will get an error.
--   This will be indicated as an exception if using <a>fromSql</a>, or a
--   Left result if using <a>safeFromSql</a>.
--   
--   <i>SPECIAL NOTE ON POSIXTIME</i>
--   
--   Note that a <a>NominalDiffTime</a> or <a>POSIXTime</a> is converted to
--   <a>SqlDiffTime</a> by <a>toSql</a>. HDBC cannot differentiate between
--   <a>NominalDiffTime</a> and <a>POSIXTime</a> since they are the same
--   underlying type. You must construct <a>SqlPOSIXTime</a> manually or
--   via <a>posixToSql</a>, or use <a>SqlUTCTime</a>.
--   
--   <i>DETAILS ON SQL TYPES</i>
--   
--   HDBC database backends are expected to marshal date and time data back
--   and forth using the appropriate representation for the underlying
--   database engine. Databases such as PostgreSQL with builtin date and
--   time types should see automatic conversion between these Haskell types
--   to database types. Other databases will be presented with an integer
--   or a string. Care should be taken to use the same type on the Haskell
--   side as you use on the database side. For instance, if your database
--   type lacks timezone information, you ought not to use ZonedTime, but
--   instead LocalTime or UTCTime. Database type systems are not always as
--   rich as Haskell. For instance, for data stored in a TIMESTAMP WITHOUT
--   TIME ZONE column, HDBC may not be able to tell if it is intended as
--   UTCTime or LocalTime data, and will happily convert it to both, upon
--   your request. It is your responsibility to ensure that you treat
--   timezone issues with due care.
--   
--   This behavior also exists for other types. For instance, many
--   databases do not have a Rational type, so they will just use the show
--   function and store a Rational as a string.
--   
--   The conversion between Haskell types and database types is complex,
--   and generic code in HDBC or its backends cannot possibly accomodate
--   every possible situation. In some cases, you may be best served by
--   converting your Haskell type to a String, and passing that to the
--   database.
--   
--   <i>UNICODE AND BYTESTRINGS</i>
--   
--   Beginning with HDBC v2.0, interactions with a database are presumed to
--   occur in UTF-8.
--   
--   To accomplish this, whenever a ByteString must be converted to or from
--   a String, the ByteString is assumed to be in UTF-8 encoding, and will
--   be decoded or encoded as appropriate. Database drivers will generally
--   present text or string data they have received from the database as a
--   SqlValue holding a ByteString, which <a>fromSql</a> will automatically
--   convert to a String, and thus automatically decode UTF-8, when you
--   need it. In the other direction, database drivers will generally
--   convert a <a>SqlString</a> to a ByteString in UTF-8 encoding before
--   passing it to the database engine.
--   
--   If you are handling some sort of binary data that is not in UTF-8, you
--   can of course work with the ByteString directly, which will bypass any
--   conversion.
--   
--   Due to lack of support by database engines, lazy ByteStrings are not
--   passed to database drivers. When you use <a>toSql</a> on a lazy
--   ByteString, it will be converted to a strict ByteString for storage.
--   Similarly, <a>fromSql</a> will convert a strict ByteString to a lazy
--   ByteString if you demand it.
--   
--   <i>EQUALITY OF SQLVALUE</i>
--   
--   Two SqlValues are considered to be equal if one of these hold. The
--   first comparison that can be made is controlling; if none of these
--   comparisons can be made, then they are not equal:
--   
--   <ul>
--   <li>Both are NULL</li>
--   <li>Both represent the same type and the encapsulated values are
--   considered equal by applying (==) to them</li>
--   <li>The values of each, when converted to a string, are equal</li>
--   </ul>
--   
--   <i>STRING VERSIONS OF TIMES</i>
--   
--   Default string representations are given as comments below where such
--   are non-obvious. These are used for <a>fromSql</a> when a
--   <a>String</a> is desired. They are also defaults for representing data
--   to SQL backends, though individual backends may override them when a
--   different format is demanded by the underlying database. Date and time
--   formats use ISO8601 date format, with HH:MM:SS added for time, and
--   -HHMM added for timezone offsets.
--   
--   <i>DEPRECATED CONSTRUCTORS</i>
--   
--   <a>SqlEpochTime</a> and <a>SqlTimeDiff</a> are no longer created
--   automatically by any <a>toSql</a> or <a>fromSql</a> functions or
--   database backends. They may still be manually constructed, but are
--   expected to be removed in a future version. Although these two
--   constructures will be removed, support for marshalling to and from the
--   old System.Time data will be maintained as long as System.Time is,
--   simply using the newer data types for conversion.
data SqlValue
class (Monad m, MonadIO m, IConnection conn, MonadBaseControl IO m) => MonadOrville conn m | m -> conn
getOrvilleEnv :: MonadOrville conn m => m (OrvilleEnv conn)
localOrvilleEnv :: MonadOrville conn m => (OrvilleEnv conn -> OrvilleEnv conn) -> m a -> m a
startTransactionSQL :: MonadOrville conn m => m String
runningQuery :: MonadOrville conn m => QueryType -> String -> m a -> m a
runOrville :: OrvilleT conn m a -> OrvilleEnv conn -> m a
mapOrvilleT :: Monad n => (m a -> n b) -> OrvilleT conn m a -> OrvilleT conn n b
data QueryType
SelectQuery :: QueryType
InsertQuery :: QueryType
UpdateQuery :: QueryType
DeleteQuery :: QueryType
DDLQuery :: QueryType
withTransaction :: MonadOrville conn m => m a -> m a
data ColumnFlag
PrimaryKey :: ColumnFlag
Default :: a -> ColumnFlag
Null :: ColumnFlag
Unique :: ColumnFlag
References :: TableDefinition entity -> FieldDefinition -> ColumnFlag
ColumnDescription :: String -> ColumnFlag
data Now
Now :: Now
data ColumnType
AutomaticId :: ColumnType
ForeignId :: ColumnType
Text :: Int -> ColumnType
VarText :: Int -> ColumnType
Date :: ColumnType
Timestamp :: ColumnType
Integer :: ColumnType
BigInteger :: ColumnType
TextSearchVector :: ColumnType
Double :: ColumnType
Boolean :: ColumnType
type FieldDefinition = (String, ColumnType, [ColumnFlag])
withPrefix :: FieldDefinition -> String -> FieldDefinition
fieldName :: FieldDefinition -> String
data IndexDefinition
IndexDefinition :: String -> Bool -> String -> String -> IndexDefinition
[indexName] :: IndexDefinition -> String
[indexUnique] :: IndexDefinition -> Bool
[indexTable] :: IndexDefinition -> String
[indexBody] :: IndexDefinition -> String
uniqueIndex :: String -> TableDefinition entity -> [FieldDefinition] -> IndexDefinition
simpleIndex :: String -> TableDefinition entity -> [FieldDefinition] -> IndexDefinition
data ConstraintDefinition
ConstraintDefinition :: String -> String -> String -> ConstraintDefinition
[constraintName] :: ConstraintDefinition -> String
[constraintTable] :: ConstraintDefinition -> String
[constraintBody] :: ConstraintDefinition -> String
uniqueConstraint :: String -> TableDefinition entity -> [FieldDefinition] -> ConstraintDefinition
dropConstraint :: TableDefinition entity -> String -> SchemaItem
data FromSql a
data FromSqlError
RowDataError :: String -> FromSqlError
QueryError :: String -> FromSqlError
class ColumnSpecifier col
selectForm :: ColumnSpecifier col => col -> SelectForm
col :: (ColumnSpecifier col, Convertible SqlValue a) => col -> FromSql a
data ToSql a b
getField :: Convertible a SqlValue => (entity -> a) -> ToSql entity ()
getComponent :: (entity -> a) -> ToSql a () -> ToSql entity ()
withFlag :: FieldDefinition -> ColumnFlag -> FieldDefinition
withName :: FieldDefinition -> String -> FieldDefinition
data SchemaItem
Table :: TableDefinition entity -> SchemaItem
DropTable :: String -> SchemaItem
Index :: IndexDefinition -> SchemaItem
DropIndex :: String -> SchemaItem
Constraint :: ConstraintDefinition -> SchemaItem
DropConstraint :: String -> String -> SchemaItem
type SchemaDefinition = [SchemaItem]
type Record = Int
type CreatedAt = UTCTime
type UpdatedAt = UTCTime
type OccurredAt = UTCTime
data TableComments a
noComments :: TableComments ()
say :: String -> (Int, Int, Int) -> String -> TableComments ()
data WhereCondition
whereAnd :: [WhereCondition] -> WhereCondition
whereOr :: [WhereCondition] -> WhereCondition
whereIn :: FieldDefinition -> [SqlValue] -> WhereCondition
whereNotIn :: FieldDefinition -> [SqlValue] -> WhereCondition
isNull :: FieldDefinition -> WhereCondition
isNotNull :: FieldDefinition -> WhereCondition
(.==) :: Convertible a SqlValue => FieldDefinition -> a -> WhereCondition
(.<>) :: Convertible a SqlValue => FieldDefinition -> a -> WhereCondition
(.<-) :: Convertible a SqlValue => FieldDefinition -> [a] -> WhereCondition
(%==) :: Convertible a SqlValue => FieldDefinition -> a -> WhereCondition
(.>) :: Convertible a SqlValue => FieldDefinition -> a -> WhereCondition
(.>=) :: Convertible a SqlValue => FieldDefinition -> a -> WhereCondition
(.<) :: Convertible a SqlValue => FieldDefinition -> a -> WhereCondition
(.<=) :: Convertible a SqlValue => FieldDefinition -> a -> WhereCondition
data SelectOptions
SelectOptions :: [WhereCondition] -> [OrderByClause] -> First Int -> First Int -> [GroupByClause] -> SelectOptions
[selectOptWhere] :: SelectOptions -> [WhereCondition]
[selectOptOrder] :: SelectOptions -> [OrderByClause]
[selectOptLimit] :: SelectOptions -> First Int
[selectOptOffset] :: SelectOptions -> First Int
[selectOptGroup] :: SelectOptions -> [GroupByClause]
where_ :: WhereCondition -> SelectOptions
order :: ToOrderBy a => a -> SortDirection -> SelectOptions
limit :: Int -> SelectOptions
offset :: Int -> SelectOptions
groupBy :: ToGroupBy a => a -> SelectOptions

-- | An associative operation.
(<>) :: Semigroup a => a -> a -> a
infixr 6 <>
data FieldUpdate
FieldUpdate :: FieldDefinition -> SqlValue -> FieldUpdate
[fieldUpdateField] :: FieldUpdate -> FieldDefinition
[fieldUpdateValue] :: FieldUpdate -> SqlValue
fieldUpdate :: Convertible a SqlValue => FieldDefinition -> a -> FieldUpdate
(.:=) :: Convertible a SqlValue => FieldDefinition -> a -> FieldUpdate
data OrderByClause
OrderByClause :: String -> [SqlValue] -> SortDirection -> OrderByClause
data SortDirection
Ascending :: SortDirection
Descending :: SortDirection
migrateSchema :: SchemaDefinition -> Orville ()
selectAll :: TableDefinition entity -> SelectOptions -> Orville [entity Record]
selectFirst :: TableDefinition entity -> SelectOptions -> Orville (Maybe (entity Record))
deleteRecord :: TableDefinition entity -> entity Record -> Orville ()
deleteWhere :: TableDefinition entity -> [WhereCondition] -> Orville Integer
findRecord :: TableDefinition entity -> Record -> Orville (Maybe (entity Record))
findRecords :: TableDefinition entity -> [Record] -> Orville (Map Record (entity Record))
findRecordsBy :: (Convertible SqlValue fieldValue, Ord fieldValue) => TableDefinition entity -> FieldDefinition -> SelectOptions -> Orville (Map fieldValue [entity Record])
insertRecord :: TableDefinition entity -> entity () -> Orville (entity Record)
insertRecordMany :: TableDefinition entity -> [entity ()] -> Orville ()
updateFields :: TableDefinition entity -> [FieldUpdate] -> [WhereCondition] -> Orville Integer
updateRecord :: TableDefinition entity -> Record -> entity key -> Orville (entity Record)
data MigrationError
MigrationLockExcessiveRetryError :: String -> MigrationError


module Database.Orville.Popper
data PopError
MissingRecord :: TableDefinition ent -> FieldDefinition -> SqlValue -> PopError
Unpoppable :: String -> PopError
data Popper a b
data Popped a
PoppedValue :: a -> Popped a
PoppedError :: PopError -> Popped a

-- | Left-to-right composition
(>>>) :: Category cat => cat a b -> cat b c -> cat a c
infixr 1 >>>

-- | Right-to-left composition
(<<<) :: Category cat => cat b c -> cat a b -> cat a c
infixr 1 <<<
abortPop :: PopError -> Popper a b
certainly :: PopError -> Popper (Maybe b) b
certainly' :: Popper a PopError -> Popper a (Maybe b) -> Popper a b
fromKern :: (a -> b) -> Popper a b
hasMany :: TableDefinition entity -> FieldDefinition -> Popper Record [entity Record]
hasManyIn :: TableDefinition entity -> FieldDefinition -> Popper [Record] (Map Record [entity Record])
hasOneIn :: TableDefinition entity -> FieldDefinition -> Popper [Record] (Map Record (entity Record))
hasManyInWhere :: TableDefinition entity -> FieldDefinition -> SelectOptions -> Popper [Record] (Map Record [entity Record])
hasManyWhere :: TableDefinition entity -> FieldDefinition -> SelectOptions -> Popper Record [entity Record]
hasOne :: (Convertible a SqlValue, Convertible SqlValue a, Ord a) => TableDefinition entity -> FieldDefinition -> Popper a (Maybe (entity Record))
hasOne' :: (Convertible a SqlValue, Convertible SqlValue a, Ord a) => TableDefinition entity -> FieldDefinition -> Popper a (entity Record)
hasOneWhere :: (Convertible a SqlValue, Convertible SqlValue a, Ord a) => TableDefinition entity -> FieldDefinition -> SelectOptions -> Popper a (Maybe (entity Record))
kern :: Popper a a
missingRecordMessage :: TableDefinition entity -> FieldDefinition -> SqlValue -> String
popMissingRecord :: Convertible a SqlValue => TableDefinition entity -> FieldDefinition -> Popper a PopError
onKern :: (a -> b -> c) -> Popper b a -> Popper b c
pop :: Popper a b -> a -> Orville (Popped b)
popThrow :: Popper a b -> a -> Orville b
popFirst :: TableDefinition entity -> SelectOptions -> Popper a (Maybe (entity Record))
popMany :: Popper a b -> Popper [a] [b]
onPopMany :: Popper a b -> Popper [a] [b] -> Popper a b
popMaybe :: Popper a b -> Popper (Maybe a) (Maybe b)
popQuery :: Orville b -> Popper a b
popRecord :: TableDefinition entity -> Record -> Popper a (Maybe (entity Record))
popRecord' :: TableDefinition entity -> Record -> Popper a (entity Record)
popTable :: TableDefinition entity -> SelectOptions -> Popper a [entity Record]
instance GHC.Base.Functor (Database.Orville.Popper.Popper a)
instance GHC.Base.Applicative (Database.Orville.Popper.Popper a)
instance Control.Category.Category Database.Orville.Popper.Popper
instance Control.Arrow.Arrow Database.Orville.Popper.Popper
instance Control.Arrow.ArrowChoice Database.Orville.Popper.Popper
instance GHC.Base.Functor Database.Orville.Popper.Popped
instance GHC.Base.Applicative Database.Orville.Popper.Popped
instance GHC.Show.Show Database.Orville.Popper.PopError
instance GHC.Exception.Type.Exception Database.Orville.Popper.PopError


module Database.Orville.Tracked
data Sign
Sign :: SignType -> TableDefinition entity -> entity Record -> Sign
[signType] :: Sign -> SignType
[signTable] :: Sign -> TableDefinition entity
[signEntity] :: Sign -> entity Record
data SignType
Inserted :: SignType
Updated :: SignType
Deleted :: SignType
signTableAs :: Typeable entity => TableDefinition entity -> Sign -> Maybe (TableDefinition entity)
signEntityAs :: Typeable entity => p (entity Record) -> Sign -> Maybe (entity Record)
signEntityFrom :: Typeable entity => TableDefinition entity -> Sign -> Maybe (entity Record)
signEntityGet :: Typeable entity => (entity Record -> a) -> Sign -> Maybe a
data TrackedOrville t m a
class (MonadOrville conn m, MonadThrow m) => MonadTrackedOrville conn m
track :: MonadTrackedOrville conn m => Sign -> m ()
insertRecordTracked :: (MonadFail m, MonadTrackedOrville conn m, Typeable entity) => TableDefinition entity -> entity () -> m (entity Record)
updateRecordTracked :: (MonadFail m, MonadTrackedOrville conn m, Typeable entity) => TableDefinition entity -> Record -> entity key -> m (entity Record)
deleteRecordTracked :: (MonadFail m, MonadTrackedOrville conn m, Typeable entity) => TableDefinition entity -> entity Record -> m ()
mapTrackedOrville :: (Functor m, Functor n) => (m (a, t) -> n (b, t)) -> TrackedOrville t m a -> TrackedOrville t n b
runTrackedOrville :: (Monoid t, Monad m) => (Sign -> t) -> TrackedOrville t m a -> m (a, t)
trackedMapper :: Monad m => (m a -> m b) -> m (a, t) -> m (b, t)
instance (GHC.Base.Monoid t, GHC.Base.Monad m) => Control.Monad.Writer.Class.MonadWriter t (Database.Orville.Tracked.TrackedOrville t m)
instance (GHC.Base.Monoid t, Control.Monad.Error.Class.MonadError e m) => Control.Monad.Error.Class.MonadError e (Database.Orville.Tracked.TrackedOrville t m)
instance (Control.Monad.Catch.MonadMask m, GHC.Base.Monoid t) => Control.Monad.Catch.MonadMask (Database.Orville.Tracked.TrackedOrville t m)
instance (Control.Monad.Catch.MonadCatch m, GHC.Base.Monoid t) => Control.Monad.Catch.MonadCatch (Database.Orville.Tracked.TrackedOrville t m)
instance (Control.Monad.Catch.MonadThrow m, GHC.Base.Monoid t) => Control.Monad.Catch.MonadThrow (Database.Orville.Tracked.TrackedOrville t m)
instance (GHC.Base.Monoid t, Control.Monad.IO.Class.MonadIO m) => Control.Monad.IO.Class.MonadIO (Database.Orville.Tracked.TrackedOrville t m)
instance (GHC.Base.Monoid t, GHC.Base.MonadPlus m) => GHC.Base.MonadPlus (Database.Orville.Tracked.TrackedOrville t m)
instance (GHC.Base.Monoid t, GHC.Base.Monad m) => GHC.Base.Monad (Database.Orville.Tracked.TrackedOrville t m)
instance (GHC.Base.Monoid t, GHC.Base.Monad m) => GHC.Base.Applicative (Database.Orville.Tracked.TrackedOrville t m)
instance (GHC.Base.Monoid t, GHC.Base.MonadPlus m) => GHC.Base.Alternative (Database.Orville.Tracked.TrackedOrville t m)
instance GHC.Base.Functor m => GHC.Base.Functor (Database.Orville.Tracked.TrackedOrville t m)
instance GHC.Enum.Enum Database.Orville.Tracked.SignType
instance GHC.Show.Show Database.Orville.Tracked.SignType
instance GHC.Classes.Eq Database.Orville.Tracked.SignType
instance (GHC.Base.Monoid t, Database.Orville.Internal.Monad.MonadOrville conn m, Control.Monad.Catch.MonadThrow m) => Database.Orville.Tracked.MonadTrackedOrville conn (Database.Orville.Tracked.TrackedOrville t m)
instance GHC.Base.Monoid t => Control.Monad.Trans.Class.MonadTrans (Database.Orville.Tracked.TrackedOrville t)
instance (GHC.Base.Monoid t, Control.Monad.Base.MonadBase GHC.Types.IO m) => Control.Monad.Base.MonadBase GHC.Types.IO (Database.Orville.Tracked.TrackedOrville t m)
instance GHC.Base.Monoid t => Control.Monad.Trans.Control.MonadTransControl (Database.Orville.Tracked.TrackedOrville t)
instance (GHC.Base.Monoid t, Control.Monad.Trans.Control.MonadBaseControl GHC.Types.IO m) => Control.Monad.Trans.Control.MonadBaseControl GHC.Types.IO (Database.Orville.Tracked.TrackedOrville t m)
instance (GHC.Base.Monoid t, Database.Orville.Internal.Monad.MonadOrville conn m) => Database.Orville.Internal.Monad.MonadOrville conn (Database.Orville.Tracked.TrackedOrville t m)
instance GHC.Show.Show Database.Orville.Tracked.Sign


module Database.Orville
